#include <vector>
#include <iostream>

template <typename Iter>
Iter Unique(Iter first, Iter last) {
    auto it1 = first; // Писатель
    auto it2 = first; // Читатель
    while (it2 != last) {
        // Копируем элемент из позиции чтения в позицию записи, но только если это разные позиции
        if (it1 != it2)
            *it1 = *it2;
        ++it1; // Сдвигаем писателя - следующий уникальный элемент будет записан сюда
        const auto& value = *it2; // Запоминаем текущее значение для сравнения

        // Пропускаем ВСЕ последовательные дубликаты текущего значения:
        // Пока не достигли конца И текущий элемент равен запомненному значению
        while (it2 != last && *it2 == value)
            ++it2;

        // После этого цикла it2 указывает на:
        // 1) Либо первый элемент, отличный от value
        // 2) Либо на last (конец диапазона)
    }

    // Возвращаем итератор, указывающий ЗА последний записанный уникальный элемент
    // Этот итератор отмечает "новый конец" диапазона с уникальными элементами
    return it1;
}

#ifdef ACTIVE_MAIN
int main() {
    std::vector<int> vec = { 1, 1, 2, 2, 2, 3, 3, 4 };

    for (const auto& x : vec)
        std::cout << x << " ";
    std::cout << std::endl;

    auto end1 = Unique(vec.begin(), vec.end());
    vec.erase(end1, vec.end());

    for (const auto& x : vec) 
        std::cout << x << " ";
    std::cout << std::endl;

    return 0;
}
#endif

/*
    Вам надо написать свою реализацию стандартного алгоритма unique. Заголовок функции должен быть таким:

    template <typename Iter>
    Iter Unique(Iter first, Iter last);

    Функция должна переупорядочить элементы диапазона [first; last) так, чтобы подряд идущие одинаковые элементы в ней не встречались.
    Функция возвращает итератор за последний элемент итоговой последовательности.
    Что останется в пределах от этого вернувшегося итератора до старого last — не важно. Время работы функции должно линейно зависеть от длины диапазона.

    В вашем решении должен быть только код этой шаблонной функции и не должно быть функции main. Использовать вызов std::unique нельзя.
*/